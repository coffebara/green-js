데이터 교환 방식
서버와 클라이언트 간에 자료를 주고받기 위해 양쪽 모두 이해할 수 있는 형식을 사용해야 한다. 
    XML은 컴퓨터에서 처리하는 모든 문서의 표준 형식이기 떄문에 웹에서 사용 가능하다는최근에는
    JSON이라는 형식을 더 많이 사용한다

JSON의 특징
    텍스트로만 구성되었기 때문에 서버와 클라이언트 사이에 주고 받을 때 전송 속도가 아주 빠르다. 
    JSON은 프로그래밍 언어나 플랫폼에 대해 독립적이기 때문에 C++이나 자바, 자바스크립트,
    파이썬 등 많은 언어에서 사용할 수 있다. 
    자바스크립트 사용자라면 누구나 알고 있는 표기법을 사용하기 떄문에 읽기도 쉽고
    필요에 따라 자바스크립트 객체로 변환하기도 쉽다. 

    {
        "이름" : 값,
        ......
    }

    중괄호 { } 사이에 '이름'과 '값'으로 구성된다. 
    JSON에서는 '이름' 부분에 반드시 큰따옴표를 붙이는 것이 큰 차이점
JSON의 '이름'
    반드시 큰따옴표(" ")로 묶어야 한다. 
    '이름'에 작은따옴표를 사용하거나 큰따옴표가 없는 이름은 사용할 수 없다

JSON 이름에는 공백space이나 하이픈(-), 언더바(_)를 함께 사용할 수 있다. 
문법적으로 다음 형식도 가능
{ "full name" : "도레미" }
{ "full-name" : "도레미" }
    하지만 이름에 공백이나 하이픈이 있을 경우 프로그램을 통해
    그 이름에 접근할 때 쉽지 않기 때문에 둘 이상의 단어로 된 이름을 사용한다면
    언더스코어(_)를 사용하는 것이 좋다. 
{ "full_name" : "도레미" }

JASON의 '값'
객체에서는 '값' 부분에 함수(메서드)도 사용할 수 있지만
JASON의 '값'에는 숫자, 문자열, boolean, null, 배열만 사용할 수 있고, 함수는 사용할 수 없다. 

JASON의 구조
    이름과 값의 쌍으로 이뤄진다. 
    데이터는 쉼표(,)로 나열된다
    객체(object)는 중괄호 ({})로 둘러쌓아 표현한다. 
    배열(array)는 대괄호([])로 둘러쌓아 표현한다. 

JSON 데이터
: JSON의 데이터는 이름과 값의 쌍으로 구성되는 데이터 이름, 콜론(:) 값의 순서로 구성된다. 
"데이터이름" : 값, ex) "name" : "식빵"

데이터의 값으로 아래 6가지가 올 수 있다. 
숫자(number), 문자열(string), 불리언(boolean), 객체(object), 배열(array), null

숫자형: JSON에서는 정수와 실수 모두 사용할 수 있지만,
8진수나 16진수를 사용한 표기법은 지원하지 않는다. 
문자열: JSON 문자열은 항상 큰따옴표(" ")로 묶어야 한다. 
논리값과 null: true/false 값을 가지는 논리형을 사용할 수도 있고 null 유형도 사용할수 있다. 
문자열, 배열 : 문자열이나 배열을 값으로 사용할 수 있다. 
JSON 문자열에 또다른 JSON 문자열을 넣을 수도 있다. 
JSON에서 배열을 사용할 때에도 일반 배열고ㅏ마찬가지로 대괄호([ ])를 사용한다. 

JSON 문자열
JSON 문자열 안에 또 다른 JSON 문자열을 지정할 수 있다. 

객체를 JSON 형식으로 변환하기
<<클라이언트에서>> 정보를 처리할 때는 객체를 사용한다. 
객체를 JSON 형식으로 저장하거나, JSON 형식을 요구하는 서버로 넘기려면
    -> 객체를 JSON 형식으로 변환해야 한다. 직렬화(stringify)라고 한다. 
    JSON.stringify(객체)

let student = {name:"도레미", major:"컴퓨터 공학", grade:"2"}
let json = JSON.stringify(student)

JSON을 객체로 변환하기
    <<서버에서>> 가져온 JSON 자료를 사용하려면 객체 형태로 변환해야 한다
    -> 이것을 파싱(parsing)이라고 한다. 
    JSON.parse(JSON 문자열)

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON stringify와 parse</title>
    <script>
        user = {
            name: 'admin', email: 'namgarambooks@naver.com', phone: '032-444-5555'
        };//user에 저장된 값을 출력
        //[object object]
        alert(user);
        // stringify: JSON 객체를 String 객체로 변환해준다. 
        userStr = JSON.stringify(user);
        //userStr : name: 'admin', email: 'namgarambooks@naver.com', phone: '032-444-5555'
        alert(userStr);//parse : string 객체를 JSON 객체로 변환해준다. 
        JSON.parse(userStr, function(key, value){
            alert(key + " " + value);
        });
    </script>
</head>
<body>
    
</body>
</html>
AJAX 서버와의 비동기 통신을 위한 방법
Asynchronous    Javascript  and     XML
AJAX란, 서버에 요청하는 것과 서버의 응답이 한꺼번에 일어나지 않는 것을 말합니다. 
(요청한 후 응답을 기다리는 동안 다른 요청을 할 수 있습니다.)
비동기적인 통신을 위해 서버와 클라이언트 사이에 주고받은 통신 방법이 XMLHttpRequest입니다. 
ES6 이후에는 fetch를 사용하고 있습니다. 

XMLHttpRequest 객체
웹 브라우저에서 서버로 데이터를 요청하고 서버에서 자료를 받아올 때는
HTTP 통신이 가능한 XMLHttpRequest 객체를 사용한다. 
XMLHttpRequest 객체의 프로퍼티와 매서드를 사용해서 자료를 주고받거나 상태를 체크한다. 
웹 페이지 전체가 아니라 필요한 부분만 자료만 가져올 수 있다. 

XMLHttpRequest 
XML 이라는 자료를 'HTTP' 프로토콜을 사용해서 'Request(요청)'한다 자룔를 요청한다
누가? 클라이언트가
응답? 서버가 자료를 전송해준다

new 예약어를 사용해서 XMLHttpRequest 객체의 인스턴스를 만든다. 
new XMLHttpRequest() 
XMLHttpRequest 객체를 만들면 서버로 자료를 요청하고 자료를 받아올 수 있다. 
let xhr = new XMLHttpRequest()
1.XMLHttpRequest 만들어주다
2.어떤자료를 가져올지 알려주기
3.서버로 HTTP요청 보내기
4.서버에서 처리해주기
5.자료 로딩하기
6.응답 자료 처리하기(출력설계)

open() - 어떤 자료를 가져올 지 지정
서버로 자료를 요청할 때 어떤 방식을 사용할 지, 어떤 자료가 필요한 지
그리고 비동기 처리 여부를 지정한다. 
open(방식, 자료 위치, 비동기 여부)
방식 : HTTP 요청 방식을 지정한다. GET이나 POST 중 하나이고 대문자로 사용해야한다. 
자료 위치 : 요청할 서버의 URL을 지정한다. 
비동기 여부: 비동기 요청인지, 동기 요청인지의 여부를 판단하는 항목. true - 비동기,
false - 동기 기본적으로 비동기 처리하므로 따로 지정하지 않으면 비동기로 처리한다

send() - 서버로 요청 전송
사용자 요청을 서버로 보내는 메서드
send(내용)
send() 괄호 안에 들어가는 매개변수는 옵션이다. 
POST 방식을 사용할 경우에는 서버로 넘길 내용을 매개변수로 넘겨주고,
GET 방식을 사용할 경우에는 null로 넘기거나 빈 상태로 남겨 둔다.

예) GET 방식을 이용해 text.txt 파일에 비동기 방식으로 연결하려면
xhr.open("GET", "text.txt", true);
xhr.send();

JSON 가져오기 연습
JSON 자료는 기본적으로 서버에 저장되어 있다. 
연습을 위해 사용자 컴퓨터를 서버로 만들어 주는 VS Code의 '라이브 서버'를 사용한다. 

readyState 프로퍼티
readyState 프로퍼티는 XMLHttpRequest 객체의 현재 상태를 나타낸다. 
객체에서 서버로 자료를 요청했는지, 자료가 도착헀는지, 사용할 준비가 되었는지 등을 알 수 있다. 
0 아직 아무 요청도 하지 않은 상태입니다. 
1 서버로 자료를 요청하고 성공한 상태입니다. 
2 서버 요청에 대한 응답으로 헤더가 도착한 상태입니다. 
3 서버에서 자료들이 로딩 중인 상태입니다. 
4 자료 처리가 끝나서 프로그램에서 사용할 수 있는 상태입니다. 
0 1 2 3 4  순서대로 반복한다
Status: 200 성공
statusText: "Ok"

readyState 값은 요청이 성공했는지를 알려주기 때문에 만약 서버에 없는 파일을 요청하더라도
readyState 값은 4. 
요청에 성공하고 서버에서 필요한 파일을 가져왔는지 체크하려면
readyState 프로퍼티 값이 4이면서 state 프로퍼티 값이 200일 경우

xhr.onreadystatechange = function() {
    if (xhr.readyState ==== 4 && xhr.state === 200 ){
        // 자료가 있고 가져오는 데 성공했다면
        ....
    }
}   

response, responseText 프로퍼티
response : 요청에 대한 응답
responseText : 요청에 대한 응답이 문자열 형태로 저장된다. 이 값을 프로그래밍에 사용. 
responseType : 응답 데이터의 종류
responseURL : 응답을 보낸 URL 
responseXML : HTML이나 XML 같은 형식의 데이터를 받아올 때 사용

콘솔 창에 다음과 같이 입력하면 어떤 값을 가져왔는지 알 수 있다. 
xhr.responseTExt    가져온 값 확인하기

https://jsonplaceholder.typicode.com/users

const url = 'https://jsonplaceholder.typicode.com/users';
fetch(url)
.then(response => response.json())
.then(users => console.log(users));

fetch(url) 코드는 url 주소에서 데이터를 가져오는 Promise 객체를 반환합니다. 
이 Promise 객체에 대해 then() 메서드를 체이닝하여,
Promise가 처리될 경우 호출되는 콜백 함수를 등록합니다. 

첫 번째 then() 메서드에서는 HTTP 응답 객체인 response를 받아와서,
response.json() 메서드를 호출하여 응답 데이터를 JSON 형식으로 파싱한 
Promise 객체를 반환합니다.

두 번째 then() 메서드에서는 이전 Promise 객체가 처리된 결과인 JSON 데이터를 받아와서,
console.log() 함수를 호출하여 콘솔에 출력합니다. 
이 떄 출력되는 데이터는 JSON 데이터를 자바스크립트 객체로 파싱한 결과입니다. 

<!-- (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
0: {id: 1, name: 'Leanne Graham', username: 'Bret', email: 'Sincere@april.biz', address: {…}, …}
1: {id: 2, name: 'Ervin Howell', username: 'Antonette', email: 'Shanna@melissa.tv', address: {…}, …}
2: {id: 3, name: 'Clementine Bauch', username: 'Samantha', email: 'Nathan@yesenia.net', address: {…}, …}
3: {id: 4, name: 'Patricia Lebsack', username: 'Karianne', email: 'Julianne.OConner@kory.org', address: {…}, …}
4: {id: 5, name: 'Chelsey Dietrich', username: 'Kamren', email: 'Lucio_Hettinger@annie.ca', address: {…}, …}
5: {id: 6, name: 'Mrs. Dennis Schulist', username: 'Leopoldo_Corkery', email: 'Karley_Dach@jasper.info', address: {…}, …}
6: {id: 7, name: 'Kurtis Weissnat', username: 'Elwyn.Skiles', email: 'Telly.Hoeger@billy.biz', address: {…}, …}
7: {id: 8, name: 'Nicholas Runolfsdottir V', username: 'Maxime_Nienow', email: 'Sherwood@rosamond.me', address: {…}, …}
8: {id: 9, name: 'Glenna Reichert', username: 'Delphine', email: 'Chaim_McDermott@dana.io', address: {…}, …}
9: {id: 10, name: 'Clementina DuBuque', username: 'Moriah.Stanton', email: 'Rey.Padberg@karina.biz', address: {…}, …}
length: 10
[[Prototype]]: Array(0) -->

프로미스
    콜백을 사용했을 때의 복잡함을 피하기 위해, ES6부터 "프로미스(promise)" 등장. 
    처리에 성공했을 때 실행할 함수와 성공하지 못했을 때 실행할 함수를 미리 약속하자~ 
    프로미스를 사용하려면 Promise 객체를 먼저 만들어야 한다. 
    성공헀을 때 실행할 함수 resolve()와 실패했을 때 실행할 함수 reject()도 함꼐 지정
    new Promise(resolve, reject)
    프로미스는 객체를 생성(제작)하는 부분과 소비하는 부분으로 나뉜다.
    프로미스 제작 코드에서 '성공'과 '실패'를 확인한 후 소비 코드로 알려준다.